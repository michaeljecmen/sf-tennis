#!/Users/michaeljecmen/Documents/src/sf-tennis/venv/bin/python
"""
SF Tennis Court Availability Checker

A fast, parallel tennis court availability checker for San Francisco Rec & Park.
Combines URL scraping and availability checking into a single executable.
Results are sorted by biking distance from your location (closest first).

Usage:
    python sf-tennis [date] [options]
    
Examples:
    python sf-tennis tomorrow
    python sf-tennis "next friday"
    python sf-tennis "oct 25"
    python sf-tennis --workers 8 "tomorrow"
    python sf-tennis --refresh-distances "tomorrow"
    python sf-tennis --address "123 Main St, SF" "tomorrow"
    
Options:
    --workers N          Number of parallel workers (default: auto-optimized)
    --refresh-distances  Refresh court distance data before checking
    --refresh            Short form of --refresh-distances
    --address "addr"     Use custom address for distance calculations
    
Setup:
    1. Install requirements: pip install selenium beautifulsoup4 requests
    2. Run: python setup_distances.py (one-time setup)
    3. Then use normally: python sf-tennis tomorrow
    4. Update distances: python sf-tennis --refresh-distances
    
Note: Completely free using web scraping - no API keys needed!
"""

import time
import json
import os
import re
import threading
import requests
from bs4 import BeautifulSoup
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime, timedelta
from selenium import webdriver
from selenium.webdriver.firefox.service import Service
from selenium.webdriver.firefox.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException
from urllib.parse import urljoin, urlparse

class SFTennisChecker:
    def __init__(self):
        self.base_url = "https://sfrecpark.org/1446/Reservable-Tennis-Courts"
        self.driver = None
        
    def scrape_court_urls(self):
        """Scrape tennis court URLs from the main page"""
        try:
            response = requests.get(self.base_url, timeout=10)
            response.raise_for_status()
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Find all links
            links = soup.find_all('a', href=True)
            urls = []
            
            for link in links:
                url = urljoin(self.base_url, link['href'])
                text = link.get_text(strip=True)
                urls.append({'url': url, 'text': text})
            
            # Filter for tennis courts
            tennis_keywords = ['tennis', 'court']
            excluded_url = "https://sfrecpark.org/1446/Reservable-Tennis-Courts"
            
            tennis_urls = []
            for url_data in urls:
                url = url_data['url'].lower()
                text = url_data['text'].lower()
                if url_data['url'] == excluded_url:
                    continue
                if any(keyword in url or keyword in text for keyword in tennis_keywords):
                    tennis_urls.append(url_data)
            
            # Filter for rec.us URLs and deduplicate by URL
            unique_courts = {}
            for url_data in tennis_urls:
                url = url_data.get('url', '')
                text = url_data.get('text', '')
                
                if 'rec.us' in url and any(keyword in text.lower() for keyword in ['tennis', 'court']):
                    # Extract base court name (remove #1, #2, etc.)
                    base_name = re.sub(r'\s+#\d+\*?$', '', text.strip())
                    if not base_name:
                        base_name = url.split('/')[-1]
                    
                    # Only keep the first occurrence of each unique URL
                    if url not in unique_courts:
                        unique_courts[url] = {
                            'name': base_name,
                            'url': url,
                            'text': text
                        }
                    else:
                        # If we already have this URL, update the name to be more generic
                        existing = unique_courts[url]
                        if '#' in existing['name'] and '#' not in base_name:
                            existing['name'] = base_name
            
            court_data = list(unique_courts.values())
            return court_data
            
        except Exception as e:
            print(f"‚ùå error scraping urls: {e}")
            return []
    
    def setup_driver(self):
        """Set up Firefox driver with optimized options"""
        firefox_options = Options()
        
        # Optimized preferences for speed
        firefox_options.set_preference("general.useragent.override", 
                                     "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36")
        firefox_options.binary_location = "/Applications/Firefox.app/Contents/MacOS/firefox"
        
        # Speed optimizations
        firefox_options.set_preference("permissions.default.image", 2)  # No images
        firefox_options.set_preference("browser.tabs.warnOnClose", False)
        firefox_options.set_preference("browser.tabs.warnOnCloseOtherTabs", False)
        firefox_options.set_preference("browser.shell.checkDefaultBrowser", False)
        firefox_options.set_preference("browser.startup.page", 0)
        firefox_options.set_preference("browser.startup.homepage", "about:blank")
        firefox_options.set_preference("dom.webdriver.enabled", False)
        firefox_options.set_preference("useAutomationExtension", False)
        
        # Additional speed optimizations
        firefox_options.set_preference("javascript.enabled", True)
        firefox_options.set_preference("dom.disable_beforeunload", True)
        firefox_options.set_preference("browser.cache.disk.enable", False)
        firefox_options.set_preference("browser.cache.memory.enable", False)
        firefox_options.set_preference("browser.cache.offline.enable", False)
        firefox_options.set_preference("network.http.use-cache", False)
        firefox_options.set_preference("media.autoplay.default", 5)  # Block autoplay
        firefox_options.set_preference("dom.push.enabled", False)
        firefox_options.set_preference("dom.serviceWorkers.enabled", False)
        
        # Try headless first
        try:
            firefox_options.add_argument("--headless")
            self.driver = webdriver.Firefox(options=firefox_options)
            return True
        except Exception:
            # Fallback to visible mode
            firefox_options = Options()
            firefox_options.set_preference("general.useragent.override", 
                                         "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36")
            firefox_options.binary_location = "/Applications/Firefox.app/Contents/MacOS/firefox"
            firefox_options.set_preference("permissions.default.image", 2)
            firefox_options.set_preference("browser.tabs.warnOnClose", False)
            firefox_options.set_preference("browser.tabs.warnOnCloseOtherTabs", False)
            firefox_options.set_preference("browser.shell.checkDefaultBrowser", False)
            firefox_options.set_preference("browser.startup.page", 0)
            firefox_options.set_preference("browser.startup.homepage", "about:blank")
            
            try:
                self.driver = webdriver.Firefox(options=firefox_options)
                self.driver.minimize_window()
                return True
            except Exception as e:
                print(f"‚ùå Error initializing Firefox: {e}")
                return False
    
    def parse_date_input(self, date_input):
        """Parse natural language date input"""
        if not date_input:
            return None
            
        date_input = date_input.lower().strip()
        today = datetime.now()
        
        if date_input == "today":
            return today
        elif date_input == "tomorrow":
            return today + timedelta(days=1)
        elif date_input.startswith("next "):
            day_name = date_input[5:]
            days_ahead = 0
            for i in range(1, 8):
                future_date = today + timedelta(days=i)
                if future_date.strftime('%A').lower() == day_name:
                    return future_date
        elif date_input in ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']:
            days_ahead = 0
            for i in range(1, 8):
                future_date = today + timedelta(days=i)
                if future_date.strftime('%A').lower() == date_input:
                    return future_date
        elif re.match(r'oct\s+\d+', date_input):
            day = int(re.search(r'\d+', date_input).group())
            return datetime(2025, 10, day)
        elif re.match(r'\d+/\d+', date_input):
            month, day = map(int, date_input.split('/'))
            return datetime(2025, month, day)
        elif re.match(r'in \d+ days?', date_input):
            days = int(re.search(r'\d+', date_input).group())
            return today + timedelta(days=days)
        
        return None
    
    def click_specific_date(self, target_date=None):
        """Click on a specific date in the date picker"""
        date_picker_selectors = [
            "//*[contains(@class, 'react-datepicker-wrapper')]",
            "//*[contains(@class, 'date') and contains(@class, 'picker')]",
            "//*[contains(@class, 'calendar')]",
            "//*[contains(@class, 'picker')]",
            "//input[@type='date']"
        ]
        
        # Open date picker
        for selector in date_picker_selectors:
            try:
                elements = self.driver.find_elements(By.XPATH, selector)
                if elements:
                    elements[0].click()
                    break
            except:
                continue
        
        if target_date:
            day_number = str(target_date.day)
            date_selectors = [
                f"//*[contains(@class, 'react-datepicker__day') and contains(text(), '{day_number}') and not(contains(text(), 'St'))]",
                f"//*[contains(@class, 'day') and contains(text(), '{day_number}')]",
                f"//*[text()='{day_number}']"
            ]
            
            for selector in date_selectors:
                try:
                    elements = self.driver.find_elements(By.XPATH, selector)
                    if elements:
                        elements[0].click()
                        return True
                except:
                    continue
        
        return False
    
    def find_duration_for_time_element(self, time_element):
        """Find duration information for a time element"""
        try:
            # Check element text for numbers
            text = time_element.text
            numbers = re.findall(r'\d+', text)
            if numbers:
                num = int(numbers[0])
                if 15 <= num <= 180:  # Reasonable duration range
                    return num
            
            # Check parent element
            parent = time_element.find_element(By.XPATH, "..")
            parent_text = parent.text
            numbers = re.findall(r'\d+', parent_text)
            if numbers:
                num = int(numbers[0])
                if 15 <= num <= 180:
                    return num
            
            # Check siblings for duration
            siblings = time_element.find_elements(By.XPATH, "following-sibling::* | preceding-sibling::*")
            for sibling in siblings[:3]:  # Check first 3 siblings
                sibling_text = sibling.text
                numbers = re.findall(r'\d+', sibling_text)
                if numbers:
                    num = int(numbers[0])
                    if 15 <= num <= 180:
                        return num
            
            # Look for duration classes
            duration_selectors = [
                ".//*[contains(@class, 'duration')]",
                ".//*[contains(@class, 'minutes')]",
                ".//*[contains(@class, 'time')]"
            ]
            
            for selector in duration_selectors:
                try:
                    duration_elem = time_element.find_element(By.XPATH, selector)
                    duration_text = duration_elem.text
                    numbers = re.findall(r'\d+', duration_text)
                    if numbers:
                        num = int(numbers[0])
                        if 15 <= num <= 180:
                            return num
                except:
                    continue
            
            return None
        except Exception:
            return None
    
    def extract_availability_info(self):
        """Extract availability information from the page"""
        availability_info = {
            'has_availability': False,
            'availability_text': '',
            'next_available': '',
            'operating_hours': '',
            'available_times': [],
            'time_slots_with_duration': [],
            'raw_text_found': []
        }
        
        # Look for time elements
        time_selectors = [
            "//*[contains(@class, 'time')]",
            "//*[contains(@class, 'slot')]",
            "//*[contains(@class, 'hour')]",
            "//*[contains(@class, 'booking')]",
            "//*[contains(@class, 'reservation')]",
            "//*[contains(text(), 'AM') or contains(text(), 'PM')]",
            "//button[contains(text(), 'AM') or contains(text(), 'PM') or contains(text(), ':')]",
            "//*[contains(@class, 'react-datepicker__time')]",
            "//*[contains(@class, 'time-picker')]",
            "//*[contains(@class, 'time-slot')]"
        ]
        
        time_elements = []
        for selector in time_selectors:
            try:
                elements = self.driver.find_elements(By.XPATH, selector)
                time_elements.extend(elements)
                if elements:
                    break
            except:
                continue
        
        # Process time elements
        for element in time_elements:
            text = element.text.strip()
            if any(pattern in text for pattern in ['AM', 'PM', ':', 'am', 'pm']):
                if len(text) < 30 and len(text) > 2:
                    availability_info['available_times'].append(text)
                    duration = self.find_duration_for_time_element(element)
                    if duration:
                        time_slot = {'time': text, 'duration_minutes': duration}
                        availability_info['time_slots_with_duration'].append(time_slot)
        
        # Check for availability patterns
        page_text = self.driver.page_source.lower()
        availability_patterns = [
            'available', 'reservation', 'book now', '7:30am to 7:30pm',
            'operating hours', 'open', 'closed', 'hours'
        ]
        
        for pattern in availability_patterns:
            if pattern in page_text:
                availability_info['raw_text_found'].append(pattern)
        
        availability_info['has_availability'] = len(availability_info['available_times']) > 0
        
        return availability_info
    
    def check_single_court(self, court_data, date_input):
        """Check availability for a single court"""
        court_name = court_data['name']
        url = court_data['url']
        
        checker = SFTennisChecker()
        
        try:
            if not checker.setup_driver():
                return {'court': court_name, 'error': 'Driver failed', 'success': False}
            
            # Navigate to page
            checker.driver.get(url)
            time.sleep(1)  # Minimal wait for page load
            
            # Parse date
            target_date = checker.parse_date_input(date_input)
            if target_date:
                checker.click_specific_date(target_date)
                time.sleep(0.5)  # Minimal wait for date selection
            
            # Extract availability
            availability = checker.extract_availability_info()
            
            if availability['has_availability']:
                return {
                    'court': court_name,
                    'url': url,
                    'availability': availability,
                    'success': True
                }
            else:
                return {
                    'court': court_name,
                    'url': url,
                    'error': 'No availability found',
                    'success': False
                }
                
        except Exception as e:
            return {
                'court': court_name,
                'url': url,
                'error': str(e),
                'success': False
            }
        finally:
            if checker.driver:
                try:
                    checker.driver.quit()
                except:
                    pass
    
    def check_all_courts(self, date_input=None, max_workers=12):
        """Check all tennis courts in parallel"""
        courts = self.scrape_court_urls()
        if not courts:
            return []
        
        # Auto-optimize worker count based on court count
        if max_workers == 12:  # Default
            if len(courts) < 20:
                max_workers = min(8, len(courts))
            elif len(courts) < 50:
                max_workers = min(12, len(courts))
            else:
                max_workers = min(20, len(courts))
        
        start_time = time.time()
        results = []
        completed = 0
        total = len(courts)
        
        # Show initial progress bar
        print(f"‚è≥ checking {total} courts...")
        
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_court = {
                executor.submit(self.check_single_court, court, date_input): court 
                for court in courts
            }
            
            for future in as_completed(future_to_court):
                result = future.result()
                results.append(result)
                completed += 1
                
                # Update progress bar every completion
                elapsed = time.time() - start_time
                progress = completed / total
                bar_length = 40
                filled_length = int(bar_length * progress)
                bar = '‚ñà' * filled_length + '‚ñë' * (bar_length - filled_length)
                
                # Calculate ETA
                if completed > 0:
                    eta = (elapsed / completed) * (total - completed)
                    eta_str = f"ETA: {eta:.0f}s" if eta > 0 else "ETA: --"
                else:
                    eta_str = "ETA: --"
                
                print(f"\r‚è≥ [{bar}] {completed}/{total} ({progress:.1%}) | {elapsed:.0f}s | {eta_str}", end='', flush=True)
        
        elapsed = time.time() - start_time
        print(f"\r‚úÖ completed {total} courts in {elapsed:.1f}s ({total/elapsed:.1f} courts/sec)")
        
        return results
    
    def format_time(self, time_str):
        """Convert time string to compact format"""
        # Convert "10:00 AM" -> "10am", "2:00 PM" -> "2pm", "1:30 PM" -> "1:30pm"
        time_str = time_str.strip()
        if ':' in time_str and ('AM' in time_str or 'PM' in time_str):
            time_part = time_str.split()[0]
            period = time_str.split()[1].lower()
            
            # Remove :00 for on-the-hour times
            if time_part.endswith(':00'):
                time_part = time_part[:-3]
            
            return f"{time_part}{period}"
        return time_str.lower()
    
    def format_court_name(self, court_name):
        """Clean up court name - remove 'Tennis Court' and everything after"""
        # Remove "Tennis Court" and everything after it
        court = re.sub(r'\s+tennis\s+court.*$', '', court_name, flags=re.IGNORECASE)
        return court.strip().lower()
    
    def load_court_distances(self):
        """Load court distances from JSON file"""
        try:
            if not os.path.exists('court_distances.json'):
                print("‚ö†Ô∏è  No distance data found. Courts will be sorted alphabetically.")
                print("üí° Run distance_calculator.py to calculate biking distances")
                return {}
            
            with open('court_distances.json', 'r', encoding='utf-8') as f:
                distance_data = json.load(f)
            
            # Create a mapping from formatted court name to distance info
            court_distances = {}
            for court in distance_data.get('courts_by_distance', []):
                court_name = court['court_name']
                formatted_name = self.format_court_name(court_name)
                distance_info = court.get('distance_info', {})
                if distance_info:
                    court_distances[formatted_name] = distance_info
            
            print(f"üìç Loaded distance data for {len(court_distances)} courts")
            return court_distances
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error loading distance data: {e}")
            return {}
    
    def sort_courts_by_distance(self, results, court_distances):
        """Sort courts by biking distance (closest first)"""
        def get_distance_key(result):
            court_name = result['court']
            formatted_name = self.format_court_name(court_name)
            distance_info = court_distances.get(formatted_name)
            if distance_info:
                return distance_info.get('duration_seconds', float('inf'))
            else:
                return float('inf')  # Put courts without distance data at the end
        
        return sorted(results, key=get_distance_key)
    
    def format_results(self, results):
        """Format results in clean tabular format"""
        # Load distance data
        court_distances = self.load_court_distances()
        
        # Only show courts with actual availability
        available = [r for r in results if r['success'] and r['availability'].get('time_slots_with_duration', [])]
        # Only show real errors (not "no availability found")
        real_errors = [r for r in results if not r['success'] and 'no availability found' not in r['error'].lower()]
        
        # Sort available courts by distance
        available = self.sort_courts_by_distance(available, court_distances)
        
        print(f"\nüìä results: {len(available)} courts available")
        if real_errors:
            print(f"‚ùå {len(real_errors)} errors")
        print("=" * 180)
        
        if available:
            print(f"{'court':<60} {'times':<120}")
            print("-" * 180)
            
            for result in available:
                court = self.format_court_name(result['court'])
                slots = result['availability'].get('time_slots_with_duration', [])
                
                # Get distance info and add to court name
                formatted_court_name = self.format_court_name(result['court'])
                distance_info = court_distances.get(formatted_court_name, {})
                if distance_info:
                    duration = distance_info.get('duration_text', '')
                    if duration:
                        court = f"{court} ({duration})"
                
                if slots:
                    # Collect all times with their durations
                    all_times = []
                    for slot in slots:
                        time_str = self.format_time(slot['time'])
                        duration = slot['duration_minutes']
                        all_times.append((time_str, duration))
                    
                    # Sort by time (convert to 24h for proper sorting)
                    def time_sort_key(time_duration):
                        time_str, duration = time_duration
                        # Convert to 24h format for sorting
                        if 'am' in time_str:
                            # Handle AM times
                            time_clean = time_str.replace('am', '').replace(':', '')
                            if ':' in time_str:
                                hour, minute = time_str.replace('am', '').split(':')
                                hour, minute = int(hour), int(minute)
                            else:
                                hour, minute = int(time_clean), 0
                            if hour == 12:
                                hour = 0
                            return hour * 60 + minute
                        else:  # pm
                            # Handle PM times
                            if ':' in time_str:
                                hour, minute = time_str.replace('pm', '').split(':')
                                hour, minute = int(hour), int(minute)
                            else:
                                hour, minute = int(time_str.replace('pm', '')), 0
                            if hour != 12:
                                hour += 12
                            return hour * 60 + minute
                    
                    all_times.sort(key=time_sort_key)
                    
                    # Format times with duration indicators
                    time_display = []
                    for time_str, duration in all_times:
                        if duration == 60:
                            time_display.append(time_str)
                        elif duration == 90:
                            time_display.append(f"{time_str}+")
                        else:
                            time_display.append(f"{time_str} ({duration}m)")
                    
                    times_display = ', '.join(time_display)
                else:
                    times_display = "no times"
                
                # Truncate if too long
                court_display = court[:57] + "..." if len(court) > 60 else court
                times_display = times_display[:117] + "..." if len(times_display) > 120 else times_display
                
                print(f"{court_display:<60} {times_display:<120}")
        
        if real_errors:
            print(f"\n‚ùå errors ({len(real_errors)}):")
            for result in real_errors[:5]:  # Show first 5 real errors
                court = self.format_court_name(result['court'])
                print(f"  {court}: {result['error'].lower()}")
            if len(real_errors) > 5:
                print(f"  ... and {len(real_errors) - 5} more")

def main():
    import sys
    import subprocess
    
    # Parse arguments
    date_input = None
    max_workers = 12  # Optimized default
    refresh_distances = False
    address_override = None
    
    if len(sys.argv) > 1:
        args = sys.argv[1:]
        
        # Check for special flags
        if '--refresh-distances' in args or '--refresh' in args:
            refresh_distances = True
            args.remove('--refresh-distances' if '--refresh-distances' in args else '--refresh')
        
        if '--address' in args:
            try:
                address_idx = args.index('--address')
                address_override = args[address_idx + 1]
                args.pop(address_idx)
                args.pop(address_idx)
            except (ValueError, IndexError):
                print("‚ö†Ô∏è  Invalid --address value")
        
        if '--workers' in args:
            try:
                worker_idx = args.index('--workers')
                max_workers = int(args[worker_idx + 1])
                args.pop(worker_idx)
                args.pop(worker_idx)
            except (ValueError, IndexError):
                print("‚ö†Ô∏è  Invalid --workers value, using auto-optimized default")
        
        if args:
            date_input = ' '.join(args)
    
    # Handle distance refresh
    if refresh_distances:
        print("üîÑ Refreshing court distances...")
        try:
            # Calculate distances directly
            print("üö¥ Calculating biking distances...")
            if address_override:
                subprocess.run([sys.executable, 'google_maps_distance_calculator.py', address_override], check=True)
            else:
                subprocess.run([sys.executable, 'google_maps_distance_calculator.py'], check=True)
            
            print("‚úÖ Distance data refreshed!")
        except subprocess.CalledProcessError as e:
            print(f"‚ùå Error refreshing distances: {e}")
            return
        except FileNotFoundError:
            print("‚ùå Required script not found. Make sure google_maps_distance_calculator.py is in the same directory.")
            return
    
    # Run checker
    checker = SFTennisChecker()
    results = checker.check_all_courts(date_input, max_workers)
    checker.format_results(results)

if __name__ == "__main__":
    main()
